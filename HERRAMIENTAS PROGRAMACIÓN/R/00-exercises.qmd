---
title: "CUNEF R - Ejercicios"
author: "Leonardo Hansa"
format: pdf
---

```{r setup}
#| include: false
knitr::opts_chunk$set(echo = FALSE, eval = FALSE, 
                      fig.height = 4, fig.width = 6, 
                      message = FALSE, warning = FALSE)
```


# 1. Primeros pasos con R

**Ejercicio 1.** Cuenta el número de flores con `Petal.Length` mayor que 5.1 en `iris`.

```{r ex1}
sum(iris$Petal.Length > 5.1)
```

**Ejercicio 2.** Comprueba qué especies tienen flores con la anchura del sépalo mayor que 3,5 y menor que 4. _Pista._ Necesitarás `&` porque tienes más de una condición. Además, para simplificar el resultado te puede venir bien la función `unique()`. Usa `? unique` para consultar la documentación. 

```{r ex2}
unique(iris$Species[iris$Sepal.Width > 3.5 & iris$Sepal.Width < 4])
```

**Ejercicio 3.** ¿Cuántas flores de cada especie hay? _Pista._ La función `table()` te será útil.

```{r ex3}
table(iris$Species)
```

**Ejercicio 4.** Calcula la media de la anchura del sépalo de las flores cuya anchura de sépalo está por debajo de la media general.
```{r ex4}
mean(iris$Sepal.Length[iris$Sepal.Width < mean(iris$Sepal.Width)])
```

**Ejercicio 5.** Calcula la mediana de la anchura del pétalo de cada especie por separado.

```{r ex5}
print("Setosa:")
median(iris$Petal.Width[iris$Species == "setosa"])
print("Versicolor:")
median(iris$Petal.Width[iris$Species == "versicolor"])
print("Virginica:")
median(iris$Petal.Width[iris$Species == "virginica"])
```

**Ejercicio 6.** Calcula el mínimo y el máximo de la longitud del pétalo para de las flores _versicolor_. Luego cuenta cuántas flores setosa y virginica hay con la longitud del pétalo entre esos valores.
```{r ex6-a}
print("Min:")
minimo_valor <- min(iris$Petal.Length[iris$Species == "versicolor"])
minimo_valor
print("Max:")
maximo_valor <- max(iris$Petal.Length[iris$Species == "versicolor"])
maximo_valor
```

```{r ex6-b}
print("Versicolor:")

especie <- "setosa"
logical_for_especie <- iris$Species == especie
petal_lengths_for_especie <- iris$Petal.Length[logical_for_especie]

true_si_mayor_que_min <- petal_lengths_for_especie > minimo_valor
true_si_menor_que_max <- petal_lengths_for_especie < maximo_valor

# Casos que cumplen ambas cosas:
# Esto es un vector lógico: true_si_mayor_que_min & true_si_menor_que_max
# Puedo sumar los valores para hacer el conteo:
sum(true_si_mayor_que_min & true_si_menor_que_max)

print("Virginica:")

especie <- "virginica"
logical_for_especie <- iris$Species == especie
petal_lengths_for_especie <- iris$Petal.Length[logical_for_especie]

true_si_mayor_que_min <- petal_lengths_for_especie > minimo_valor
true_si_menor_que_max <- petal_lengths_for_especie < maximo_valor

sum(true_si_mayor_que_min & true_si_menor_que_max)
```

**Ejercicio 7.** ¿Qué pasa si usas la función `plot()` con el dataframe `iris`? ¿Cómo interpretas lo que ves?

```{r ex7}
plot(iris)
```


**Ejercicio 8.** Si escribes `Titanic` en la consola verás un conjunto de datos con un formato un poco feo para el análisis. Usa `as.data.frame()` para convertirlo a un data frame y asígnalo a una variable (objeto) en R (elige el nombre que quieras). Ahora tienes un data frame cargado en memoria. 

- Verifica que el data frame es un data frame (con `is.data.frame()`).
- Comprueba las clases de las columnas del data frame. 
- Cuenta (o suma) el número de personas que sobrevivieron y el número de personas que no. Si tienes dudas sobre los datos, ejecuta `? Titanic` para acceder a la ayuda (sí, también tienes ayuda sobre conjuntos de datos en R). 
- Cuenta el número de niños (`children`) que había en el barco. 
- Cuenta el número de hombres que había en primera clase. 
- ¿Había niños entre los miembros de la tripulación? ¿Y mujeres?

```{r ex8 }
df_titanic <- as.data.frame(Titanic)

class(df_titanic)

class(df_titanic$Class)
class(df_titanic$Sex)
class(df_titanic$Age)
class(df_titanic$Survived)
class(df_titanic$Freq)

print("Survived:")
sum(df_titanic$Freq[df_titanic$Survived == "Yes"])
print("Didn't survive")
sum(df_titanic$Freq[df_titanic$Survived == "No"])

sum(df_titanic$Freq[df_titanic$Age == "Child"])

sum(df_titanic$Freq[df_titanic$Class == "1st" & df_titanic$Sex == "Male"])

print("Children:")
sum(df_titanic$Freq[df_titanic$Age == "Child" & df_titanic$Class == "Crew"])
print("Women:")
sum(df_titanic$Freq[df_titanic$Sex == "Female" & df_titanic$Class == "Crew"])
```

# 2. Lectura de ficheros

**Ejercicio 1** 

- Read all the sheets of the Excel file `01_ ACCIDENTES POR TIPO EN  DISTRITOS.xls`. You should find some trouble with one of the years if you just copy and paste what I typed. Fix it.
- Create one data frame for each sheet. How many rows and columns each one has? _Hint._ `nrow()`, `ncol()` and `dim()` may help. 
- What is the average number of accidents per type in 2009? And the standard deviation? _Hint._ You should use the `$` notation.
- What are the names of the columns? Do you consider them appropriate? _Hint._ `names()`.

**Ejercicio 2 (janitor)**

- Instala el paquete `janitor` y cárgalo.
- Usa `clean_names()` sobre `iris` para cambiar el formato de los nombres de columnas. _Pista._ Ten en cuenta que si solo ejecutas `clean_names(mi_data_frame_guay_recien_creado)`, R te mostrará por consola el resultado, pero los nombres del data frame seguirán iguales. Necesitas asignar el resultado al data frame de nuevo , con ` <- `. 

**Ejercicio 3.** 

- Lee el fichero `iris2.csv` con la función `read_csv()` (paquete readr). 
- ¿Cuántas columnas hay? ¿Qué nombres tienen? ¿Tiene sentido?

# 3. dplyr

**Ejercicio 1.** What are the differences between `glimpse(df_mtcars)` and `df_mtcars %>% glimpse()`? 

**Ejercicio 2.** In the mtcars data frame decide which columns can be stored as integer without losing information and change them. For changing the type of an object or vector you can use `as.integer()`. For instance, `class(as.integer(4, 6, 1))`.

```{r dplyr-ex2}
df_mtcars %>% 
  mutate(
    cyl = as.integer(cyl), 
    vs = as.integer(vs), 
    am = as.integer(am), 
    gear = as.integer(gear), 
    carb = as.integer(carb)
  )
```

**Ejercicio 3.** Based on the `df_inventado` data frame built on the _dplyr columns_ section, now you make some calculations. You will need `mutate()` You can decide when to overwrite the data frame with the new calculations or just print them on the console.

1. Compute the total area of each store.
2. Calculate how many euros each customer spends, per store.
3. Calculate how many euros each customer spends on average, in total. _Hint._ For doing this, `summarise()` is very useful and you can read the documentation for learning how to use it. However, you can also use an approach with vectors using `$` and the functions `sum()` or `mean()`.
4. If the store is white or blue, reduce its length in 5 meters; else, increase it 10 meters. _Hint._ `? if_else()`. You should also write the condition with `%in%`. For learning how to do this, play in the console with `"white" %in% c("white", "blue")` or `"red" %in% c("white", "blue")` and try to understand what's happening and how you can use it inside `mutate()`.
5. If all the customers in a day went to the store at the same time, how many squared meters per customer would there be in each store?

```{r dplyr-ex3}
# Ejercicio 1
df_inventado %>% 
  mutate(area = ancho * long)

# Ejercicio 2
df_inventado %>% 
  mutate(euros / clientes)

# Ejercicio 3
df_inventado %>% 
  summarise(sum(euros) / sum(clientes))

sum(df_inventado$euros) / sum(df_inventado$clientes)

# Ejercicio 4
df_inventado %>% 
  mutate(nueva_long = if_else(col %in%  c("white", "blue"), long - 5, long + 10)) %>% 
  select(nueva_long, long)

# Ejercicio 5
df_inventado %>% 
  mutate(area = long * ancho, sqm_per_cust = area / clientes) %>% 
  select(clientes, area, sqm_per_cust)
```

**Ejercicio 4.** Based on the `starwars` data frame, answer these questions.

- What are the names of the columns?
- What are the classes of each column?
- What are the dimensions of the data frame (number of rows and columns)?

**Ejercicio 5.** Get the distinct combinations between `eye_color` and `gender` from `starwars` and create a data frame with them. Export this data frame or tibble to a csv file using a function from the readr library. _Hint._ After running `library(readr)`, write on the console or the script `write_` and let the autocompletion propose you some alternatives. Decide which function you should use. _Another hint._ There are several solutions for exporting the file. Anyway, remember to use `?` for reading the help of a function.

```{r dplyr-ex5, eval=FALSE}
new_df <- starwars %>% 
  distinct(eye_color, gender)

library(readr)
write_csv(new_df, "new_file_super_cool.csv")
```

**Ejercicio 6.** Read the help of `na.omit()` function for removing all the rows with at least one `NA` value from the `starwars` data frame. Create a new dataframe with the data. Export the new data frame to a csv file (separated with **comma**).

**Ejercicio 7 **

1. Read the file `volpre2019.csv` and create a data frame with its data. Name it however you like. It stores data about the volume and the price of lots of products at MercaMadrid. 

2. Call the library janitor (install it if needed) and use the `clean_names()` function on the data frame (overwrite it). 

3. Explore the data frame with the functions you know. `nrow`, `ncol` (you can use `dim()` instead), `glimpse()`. Remember to use `summary()` too. 

4. Count how many `NA` values there are in the `fecha_desde` column. _Hint._ For now it is OK if you just use `is.na()` for building a logical vector and then `sum()` for adding the number of cases with `NA`. 

5. Exclude the cases with `fecha_desde` as `NA` and overwrite the data frame. 

6. Get the distinct origins (`desc_origin` column) of `"VACUNO"` productos (`desc_variedad_2`).

7. Select four products from the `desc_variedad_2` column and extract the months when they are available (`fecha_desde`) and the origin. Do it separately for each of them. The final data frame for each product should have two columns. Arrange that data frame by `desc_origin`. The function you need is `arrange()`. _Suggestion._ For selecting the products, I used `distinct()` on the column and then `sample_n(4)`, everything linked with pipes ` %>% `. Read the documentation on `sample_n()` if needed.

```{r dplyr-ex7}
# Ejercicio 1
library(readr)
df_merca <- read_csv2("data/volpre2019.csv")

# Ejercicio 2
library(janitor)
df_merca <- clean_names(df_merca)

# Ejercicio 4
sum(is.na(df_merca$fecha_desde))

# Ejercicio 5
df_merca <- df_merca %>% 
  filter(!is.na(fecha_desde))

# Ejercicio 6
df_merca %>% 
  filter(desc_variedad_2 == "VACUNO") %>% 
  distinct(desc_origen)

# Ejercicio 7
df_merca %>% 
  distinct(desc_variedad_2) %>% 
  sample_n(4)

df_merca %>% 
  filter(desc_variedad_2 == "CONCHA") %>% 
  select(fecha_desde, desc_origen) %>% 
  arrange(desc_origen)
```

**Ejercicio 8.** Based on the `storms` data frame, built on the _dplyr-aggregate_ section.

1. What can you learn applying `summary()` to the tibble?
2. Which are the different values at the `name` column? These are the storms and hurricanes we wil be working with. Create a tibble with one column containing this unique names. 
3. Which are the different available status? Don't create the tibble: just print it on the console. 
4. Which are the different combinations between status and pressure?

**Ejercicio 9 (Based on the `storms` data frame).** For the storms, depressions and hurricanes that took place between 1975 and 1980, create a new column with the mean and standard deviation of the wind. Create a new column substacting the mean from wind and then divide by the standard deviation. Calculate with `summarise()` the mean and the standard deviation of this new column. What happened?

```{r dplyr-ex9}
df_storms %>% 
  filter(year >= 1975, year <= 1980) %>% 
  mutate(mean_wind = mean(wind), 
         sd_wind = sd(wind), 
         new_column = (wind - mean_wind) / sd_wind) %>% 
  summarise(mean(new_column), sd(new_column))
```

**Ejercicio 10 (Based on the `storms` data frame).**

1. For the registers where `hu_diameter` is not `NA`, calculate the minimun pressure, the median, the average and the maximum

```{r dplyr-ex10a}
df_storms_pressure <- df_storms %>% 
  filter(!is.na(hu_diameter)) %>% 
  summarise(
    min = min(pressure), 
    media = mean(pressure),
    mediana = median(pressure), 
    max = max(pressure)
  )
df_storms_pressure
```

2. Are there more registers below the average or above?

```{r dplyr-ex10b}
df_storms %>% 
  filter(!is.na(hu_diameter)) %>% 
  mutate(presion_media = mean(pressure)) %>% 
  summarise(above_avg = sum(pressure >= presion_media), 
            below_avg = sum(pressure < presion_media))
```

**Ejercicio 11 (Based on the `storms` data frame).** For the hurricane, calculate the average `ts_diameter`. _Hint._ It is not `NA`.

```{r dplyr-ex11}
df_storms %>% 
  filter(status == "hurricane") %>% 
  summarise(media = mean(ts_diameter, na.rm = TRUE))
```

# 4. Dataviz with ggplot2

For the next Ejercicios, complete the gaps (`...`) within the pieces of code.

## Scatter plots

### Ejercicio 1

**1a.** Have a look at the `mtcars` data frame with `glimpse()` and `? mtcars`. Then create a scatter plot of the miles per gallon (on the y axis) and the weight (on the x axis). For creating the plot, just fill in the dots in the next code.

```{r ggplot-ex1a, echo=TRUE, eval=FALSE}
library(...)
ggplot(...) +
  geom_point(aes(x = wt, y = mpg))
```

```{r ggplot-ex1a-sol}
library(ggplot2)
ggplot(mtcars) +
  geom_point(aes(x = wt, y = mpg))
```

**1b.** Repeat the previous plot, colouring all the points from the previous plot in red. Notice that since the color doesn't depend on the data frame, it is typed outside the `aes()` function.

```{r ggplot-ex1b, echo=TRUE}
ggplot(...) +
  geom_point(aes(...), colour = "red")
```

```{r ggplot-ex1b-sol}
ggplot(mtcars) +
  geom_point(aes(x = wt, y = mpg), colour = "red")
```

**1c.** Repeat the same plot but colouring the dots based on their displacement value (`disp` column).

```{r ggplot-ex1c, echo=TRUE}
ggplot(...) +
  geom_point(aes(x = ..., y = ..., colour = ...))
```

```{r ggplot-ex1c-sol}
ggplot(mtcars) +
  geom_point(aes(x = wt, y = mpg, colour = disp))
```

**1d.** Instead of colouring the dots in different colours, make them have a different size depending again on the `disp` variable.

```{r ggplot-1d}
ggplot(...) +
  geom_point(aes(...))
```

```{r ggplot-1d-sol}
ggplot(mtcars) +
  geom_point(aes(x = wt, y = mpg, size = disp))
```

### Ejercicio 2

**2a.** Scatter plots can also be used for non continuous data. In R, when dealing with continuous data, we usually use the `numeric` class (weight, heights, incomes,...). But there are some variables that are written with numbers but aren't continuous (age, number of cylinders, identificators). What is the class of the number of cylinders in the `mtcars` data frame? Remember to use `? mtcars` if you don't know the name of the column in the data frame.

**2b.** What are its unique values. Fill in the gap:

```{r ggplot-2b, echo=TRUE}
mtcars %>% distinct(...)
```

**2c.** Based on the distinct values, the class of the column it's not the best. Try to plot a scatter plot the miles per gallon (y axis) versus the number of cylinders.

```{r ggplot-2c, echo=TRUE}
ggplot(mtcars) +
  geom_point(aes(...))
```

```{r ggplot-2c-sol}
ggplot(mtcars) +
  geom_point(aes(x = cyl, y = mpg))
```


**2d.** In the previous Ejercicio, in general, nothing wrong. But the x axis shows values that are not possible (5 and 7). This is because the number of cylinders should be a categorical variable and not a numerical one. Let's fix it.  In R, categorial variables belong to a new class: `factor`. We can easily convert some variables to the factor class with the `as.factor()` function. Fill in the gaps for plotting the same scatter plot as before and compare the result.

```{r ggplot-2d, echo=TRUE}
mtcars <- mtcars %>% 
  mutate(cyl = as.factor(cyl))

ggplot(...) +
  ...
```

```{r ggplot-2d-sol}
mtcars <- mtcars %>% 
  mutate(cyl = as.factor(cyl))

ggplot(mtcars, aes(x = as.factor(cyl), y = mpg)) +
  geom_point()
```


### Ejercicio 3

**3a.** With ggplot2 you have available the `diamonds` data frame. Have a look at its info with `? diamonds` and `glimpse(diamonds)`.

**3b.** Create a scatter plot with the price of the diamonds (y axis) vs the weight of the diamond (x axis). There are more than 50,000 diamonds, so it may take longer than expected plotting the plot.

```{r ggplot-3b, echo=TRUE}
ggplot(diamonds) + 
  ...(aes(...))
```

```{r ggplot-3b-sol}
ggplot(diamonds) + 
  geom_point(aes(x = carat, y = price))
```

**3c.** There are too many dots, therefore they overlap and the result is a cloud of data not very comfortable to look at. Let's fix it. First, reduce the size of all the points. Try with `size = 0.5`.

```{r ggplot-3c, echo=TRUE}
ggplot(...) + 
  ...(aes(...), ...)
```

```{r ggplot-3c-sol}
ggplot(diamonds) + 
  geom_point(aes(x = carat, y = price), size = 0.5)
```

**3d.** One more thing to improve it. We can give some transparency to the points. This will help us seeing where there are too many points together. The parameter used for this is called `alpha` (very common not only in R but also in other programming languages that deal with color, such as CSS). This parameter takes values from 0 (invisible) to 1 (opaque). Set this value to 0.1, alongside the already defined size. This time, you write the code from scratch, but remember that copy-pasting is key when programming.

```{r ggplot-3d-sol}
ggplot(diamonds) + 
  geom_point(aes(x = carat, y = price), size = 0.5, alpha = 0.1)
```

**3e.** Now we are giving some color to the plot. This color will be based on the clarity of the diamonds, which is a column from the data frame. We are setting the transparency to 0.4, to make that overlapping easier to see.

```{r ggplot-3e-sol}
ggplot(diamonds, aes(x = carat, y = price,color=clarity)) +
  geom_point(alpha=0.4)
```


### Ejercicio 4

**4a.** Let us create a data frame from the `countries_of_the_world.csv`. We will use the `clean_names()` function from the janitor library to simplify the names of the columns. We are also removing all the rows with some `NA` value. Now, plot the `phones_per_1000` columns against the `literacy_percent` column, with a scatter plot.

```{r ggplot-4a, echo=TRUE}
library(readr)
library(janitor)

df_countries <- read_csv("data/countries_of_the_world.csv", locale = locale(decimal_mark = ",")) %>% 
  clean_names() %>% 
  na.omit()

glimpse(df_countries)

## YOUR CODE FOR THE PLOT HERE ##
...
```

```{r ggplot-4a-sol}
library(readr)
library(janitor)

df_countries <- read_csv("data/countries_of_the_world.csv", locale = locale(decimal_mark = ",")) %>% 
  clean_names() %>% 
  na.omit()

glimpse(df_countries)

ggplot(df_countries) + 
  geom_point(aes(x = literacy_percent, y = phones_per_1000))
```

**4b.** In the same plot, colour each point based on its region.

```{r ggplot-4b-sol}
ggplot(df_countries) + 
  geom_point(aes(x = literacy_percent, y = phones_per_1000, col = region))
```

**4c.** Make scatter plot of the `service` columns vs. the `agriculture` column. Change the size of each point depending on each population and color all of them in `"darkblue"`.

```{r ggplot-4c-sol}
ggplot(df_countries) + 
  geom_point(aes(x = agriculture, y = service, size = population), color = "darkblue")
```

## Line plots

### Ejercicio 1

**1a.** From the `economics` data frame plot `unemploy` vs `date` using a line plot. You will need `geom_line()`.

```{r ggline-1a-sol}
ggplot(economics, aes(x = date, y = unemploy)) +
  geom_line()
```

**1b.** Using dplyr, calculate a new column as the unemployment rate (umemployment divided by the population). Plot this column as a time series, in a similar way you did before.

```{r ggline-1b, echo=TRUE}
economics_new <- ... %>% 
  ...(unemployment_rate = ...)

# Code for the plot:
...
```

```{r ggline-1b-sol}
economics_new <- economics %>% 
  mutate(unemployment_rate = unemploy / pop)

ggplot(economics_new) + 
  geom_line(aes(x = date, y = unemployment_rate))
```

**1c.** Something comfortable about ggplot2 is that it is also able to make some calculations. For intance, in the previous plot, it wasn't necessary that dplyr step. We can calculate the unemployment rate on the fly. Try to use the formula `umemploy / pop` when specifying the y axis.

```{r ggline-1c, echo=TRUE}
... + 
  ...(...(x = ..., y = ...))
```

```{r ggline-1c-sol}
ggplot(economics) + 
  geom_line(aes(x = date, y = unemploy/pop))
```

### Ejercicio 2

**2a.** From the `ChickWeight` data frame, create a lines plot with the evolution over Time of the `weight` variable. Take into account that we need a different line for each `Chick`. For achieving this, map the `Chick` column to the `group=` parameter, inside the `aes()` function. 

```{r ggline-2a, echo=TRUE}
... + 
  ...(aes(x = ..., y = ..., group = ...))
```

```{r ggline-2a-sol}
ggplot(ChickWeight) + 
  geom_line(aes(x = Time, y = weight, group = Chick))
```

**2b.** Now colour each line depending on the `Diet` the chick has received.

```{r ggline-2b-sol}
ggplot(ChickWeight) + 
  geom_line(aes(x = Time, y = weight, group = Chick, colour = Diet))
```

## Column plots

**Ejercicio 1.** Generate a column plot similar to the last boxplot on the notes, but comparing the average of the gpd_per_capita. _Hint._ Have a look at the documentation of `geom_col()` for learning how to set a dodge position in the columns. You are provided with the boxplot code. The data frame `df_countries` is built within the ggplot2 module.

```{r ggcol-1, echo=TRUE}
df_countries %>% 
  mutate(literacy_percent_90 = literacy_percent > 90) %>%
  ggplot() + 
  geom_boxplot(aes(x = literacy_percent_90, y = gdp_per_capita, fill = region))
```

```{r ggcol-1-sol}
df_countries %>% 
  mutate(literacy_percent_90 = literacy_percent > 90) %>%
  group_by(region, literacy_percent_90) %>% 
  summarise(media = mean(gdp_per_capita)) %>% 
  ggplot(aes(x = literacy_percent_90, y = media, fill = region)) + 
  geom_col(position = "dodge")
```

**Ejercicio 2.** Using the `biopics` data frame from the `fivethirtyeight` library, with dplyr calculate how much money each `type_of_subject` made --there are many rows for which this piece data is not available. Make a column plot for showing this result, originally using `type_of_subject` as the $x$ axis. Then flip the coordinates so that they columns are horizontal. Also, arrange the data somehow so that the plot shows the data from more money to less money. _Hint._ For any questions regarding the dataset, you can use the documentation of the package, with `? biopics`. Also, for ordering the data, you can use the ggplot2 function `reorder()` or working with factors. I like the function `as_factor()` from the forcats package for this.

```{r ggcol-2-sol}
df_biopics %>% 
  group_by(type_of_subject) %>% 
  summarise(money = sum(box_office, na.rm = TRUE)) %>% 
  ggplot(aes(x = reorder(type_of_subject, money), y = money)) + 
  geom_col() + 
  coord_flip()
```
**Ejercicio 3.** Repeat the previous Ejercicio but now also calculate the number of movies for each `type_of_subject` and use this data for coloring the columns. 

```{r ggcol-3-sol}
df_biopics %>% 
  group_by(type_of_subject) %>% 
  summarise(money = sum(box_office, na.rm = TRUE), 
            number = n()) %>% 
  ggplot(aes(x = reorder(type_of_subject, money), y = money, fill = number)) + 
  geom_col() + 
  coord_flip()
```

**Ejercicio 4.** Count the number of movies per `year_release` and country and create a column plot with the evolution. Color each column with the `country` information, so that each column will show the number of movies from a country in a particular year.

```{r ggcol-4-sol}
df_biopics %>% 
  group_by(country, year_release) %>% 
  summarise(number_of_movies = n()) %>% 
  ggplot() + 
  geom_col(aes(x = year_release, y = number_of_movies, fill = country))
```

**Ejercicio 5.** Replicate the next plot. It shows the number of movies per `subject_sex` and `type_of_subject`. 

```{r ggcol-5-sol, eval=TRUE}
library(dplyr)
library(ggplot2)
df_biopics <- fivethirtyeight::biopics

df_biopics %>% 
  group_by(subject_sex, type_of_subject) %>% 
  summarise(number = n()) %>% 
  ggplot() + 
  geom_col(aes(x = subject_sex, y = number, fill = type_of_subject), position = "dodge")
```

## Boxplots

**Ejercicio 1.** Create boxplots for each `type_of_subject`. Make it one only plot with several boxplots, all of them horizontal.

```{r ggbox-1-sol}
df_biopics %>% 
  ggplot() + 
  geom_boxplot(aes(x = type_of_subject, y = box_office)) + 
  coord_flip()
```

## Facets

**Ejercicio 1.** Show the evolution of number of movies, separately by Female and Male.

```{r ggfacet-1-sol}
df_biopics %>% 
  group_by(subject_sex, year_release) %>% 
  summarise(number = n()) %>% 
  ggplot() + 
  geom_line(aes(x = year_release, y = number)) + 
  facet_wrap(~ subject_sex)
```

**Ejercicio 2.** Plot with columns the number of movies whose subject is Female or Male, separately by `country`. Some dplyr calculations will be needed. Make sure that the $y$ axis are allowed to be different to each other.

```{r ggfacet-2-sol, eval=TRUE}
df_biopics %>% 
  group_by(subject_sex, country) %>% 
  summarise(number = n()) %>% 
  ggplot() + 
  geom_col(aes(x = subject_sex, y = number)) + 
  facet_wrap(~ country, scales = "free_y")
```



# 5. Elements of programming

## Functions

**Ejercicio 1.** Create a function that receives a vector `x` of numbers and a number `a` and plots, based on them, the curve of the mathematical function $f(x) = xln(ax)$ being $a$ a positive real number. Make sure that `a` equals 1 by default. The function should include this vector as the column of a data frame (`tibble()` function is needed). Then it will create another column with the formula of the mathematical function, with dplyr. Finally, with ggplot2, it will plot the curve. A line plot will suffice. For checking that the function works correctly, call it with the vector generated by this code: `seq(0.01, 1, by = 0.01)`. Try different `x` and `a` cases to see how the plot changes.

```{r funct-1-sol}
library(dplyr)
library(ggplot2)

xlnx <- function(x, a = 1){
  
  df <- tibble(x = x) %>% 
    mutate(y = x * log(a * x))
  
  ggplot(df) + 
    geom_line(aes(x = x, y = y))
}

xlnx(seq(0.01, 1, by = 0.01))
# xlnx(seq(1, 100, by = 1), a = 0.01)
```


**Ejercicio 2.** In the function you created before, include a piece of code that will avoid accepting cases where the logarithm will be evaluated under negative numbers.

**Ejercicio 3.** We are going to define a function that reads a csv about air quality in Madrid, fix the format of two columns and returns it. After that, we will merge all the information from the files into one only data frame. The files are the ones that begin with `NO2` or `CO`. First, the function will receive the path of a file. It reads it (do this with readr; guess the function) and now we have to use dplyr for fixing the columns `mes` and `dia`. We want them to be numeric. `mes` is easy but for `dia` you will need to use some character treatment. Try to use `str_remove()` from the stringr package. Now make sure the function returns the data frame you created. Also, exclude the `magnitud` function: it is not necessary because the last columns specifies the magnitude. The joining stuff is the next Ejercicio. For now, make sure that the function works for the six data frames.

```{r funct-3-aux}
library(readr)
library(janitor)
library(tidyr)
read_csv2("../data/sesiones/datos2017.csv") %>% 
  clean_names() %>%
  select(-municipio, -provincia, -punto_muestreo, -starts_with("v")) %>% 
  # filter(estacion == 4) %>%
  filter(magnitud == 6) %>%
  pivot_longer(starts_with("d"), names_to = "dia", values_to = "dato") %>% 
  mutate(dato_co = as.numeric(dato)) %>% 
  select(estacion, magnitud, ano, mes, dia, dato_co) %>% 
  write_csv("../data/sesiones/CO_2017.csv")
```

```{r funct-3-sol}
library(stringr)

trata_fichero <- function(ruta_al_fichero){
  df <- read_csv(ruta_al_fichero) %>% 
    mutate(mes = as.numeric(mes), 
           dia = str_remove(dia, "d"), 
           dia = as.numeric(dia), 
           magnitud = NULL)  
  
  return(df)
}

# trata_fichero("../../data/NO2_2017.csv")
# trata_fichero("../../data/NO2_2018.csv")
trata_fichero("data/NO2_2019.csv")
trata_fichero("data/CO_2019.csv")
```

**Ejercicio 4.** Now we want to mix all the information. Create one data frame with all the data about NO2 and another one about CO. Use `bind_rows()` from dplyr for this. After that, join them all with `inner_join()`. How many rows are there? Do the same with `full_join()`, `right_join()`, and `left_join()`. What differences do you see? 

```{r funct-4-sol}
inner_join(
  bind_rows(
    trata_fichero("data/NO2_2017.csv"),
    trata_fichero("data/NO2_2018.csv"),
    trata_fichero("data/NO2_2019.csv")
  ), 
  bind_rows(
    trata_fichero("data/CO_2017.csv"),
    trata_fichero("data/CO_2018.csv"),
    trata_fichero("data/CO_2019.csv")
  )  
) %>% 
  nrow()
```

**Ejercicio 5.** Could you guess what the result of the next code is, without executing it? What is the rol of each `c`?

```{r funct-5, echo=TRUE}
c <- 1
c(c = c)
```

**Ejercicio 6.**. The `letters` vector contains all the letter from `"a"` to `"z"`. You can select a random sample with the `sample()` function. Create a function that receives an integer number $n$, then it creates a sample of $n$ letters. After that, it sorts the letters and finally it collapses them all with the `paste0()` function and the `collapse=` attribute.

**Ejercicio 7.** Create a function similar to the previous one but, instead of generating a sample from `letters`, it generates two samples: one with `letters` and one from `LETTERS`. The function must receive one argument for the number of elements from `letters` and another one for `LETTERS`. Then it will create one vector with the two samples (use `c()`). Now sort that vector and collapse all the letters. 

**Ejercicio 8.** Create a function that receives two columns from the `iris` data frame as two characters and multiplies these two columns. Create another one with the this product you just calculated. Do **not** use dplyr.

**Ejercicio 9.** Create a function that reads the file `human_resources.csv`. The path should be one of the arguments of the function. Then it will select all the columns except sales and salary. Now generate a random logical vector whose length will be the number of rows of the data frame. This vector should have a bigger amount of `TRUE`s than `FALSE`s: the weight should be an attribute of the function (it consists just on a vector of two numbers whose addition is 1, e.g., 0.7 and 0.3). This will be used for splitting the data frame into two data frames. This can be done with `filter()`. Then use the `glm()` for developing a predictive model with the first part of the data frame (the biggest one). Then use the other data frame for making a prediction with the `predict()` model. You can check how many cases you have correctly predicted with the `table()` function. Make the function returning this table. You have just developped a model for predicting which employees are more inclined to leaving the company.

```{r funct-9-sol}
library(tidyverse)

genera_primer_dataframe <- function(ruta, pesos){
  df_hr <- read_csv(ruta, col_types = cols()) %>% 
    select(-sales, -salary)
  
  filas_train <- sample(c(TRUE, FALSE), 
                        size = nrow(df_hr), 
                        replace = TRUE, 
                        prob = pesos)
  
  df_hr_train <- df_hr %>% 
    filter(filas_train)
  
  modelo <- glm(left ~ ., 
                data = df_hr_train, 
                family = binomial)
  
  df_hr_test <- df_hr %>% 
    filter(!filas_train)
  
  dato_real <- df_hr_test$left
  
  prediccion <- predict(modelo, 
                        newdata = df_hr_test %>% select(-left), 
                        type = "response")
  
  prediccion2 <- if_else(prediccion > 0.3, 1, 0)
  
  return(table(dato_real, prediccion2))
  
}

genera_primer_dataframe("../data/sesiones/human_resources.csv", 
                        c(0.7, 0.3))

```

**Ejercicio 10.** Have a look at these codes and try to guess which will be the value of `a`, `aa` and `aaa`. Don't run the code until you have an idea of the final result. 

```{r funct-10a, echo=TRUE}
a <- 1

mi_funcion <- function(b){
  if(b > 0){
    a <- 100
  } else {
    a <- -50
  }
  
}

mi_funcion(10)
a
```

```{r funct-10b, echo=TRUE}
aa <- 0

mi_funcion2 <- function(b){
  
  if(is.character(b)){
    aa <- aa + 10
  } else if(is.numeric(b)){
    aa <- aa - 20
  }
  
}

mi_funcion2("hola")
aa
```

```{r funct-10c, echo=TRUE}
mi_funcion3 <- function(aaa, b){
  aaa <- aaa + b
  return(aaa)
}

b <- mi_funcion3(3, 4)
aaa
```

**Ejercicio 11.** Create a function with two attributes. The first one is called `case=` and it will receive a word. The second one is called `times=` and it receives an integer number. If the word it receives is `"dados"` or `"Dados"`, it generates two vectors of length `times`, with values from 1 to 6. Create another vector adding these two vectors and calculate which is the more frequent result. If the word is `"coin"` or `"Coin"`, then simulate flipping a coin with the `bernoulli()` function and calculate the probability of getting each result. Flip the coin the number of times indicated in the `times=` attribute of the function. If the received word is something else, print `"I don't know what to do with this"`.

**Ejercicio 12.** Create a function for calculating the monthly installment of a French bank loan. The input should be the principal amount, the annual interest rate and the period (number of years). Try it with a 150.000 € loan, an interest rate of 1.50% to be returned in 25 years. The formula, given we are working on a French loan, is: 

$$a = C \cdot \frac{i/12}{1 - (1 + i/12)^{-12n}},$$

where $a$ is the monthly installment, $C$ is the borrowed amount, $i$ is the annual interest rate and $n$ is the number of years the monthly installments must be paid.

```{r funct-12}
# a = (C0*i)*(1-(1+i)-n)-1,
calcula_cuota <- function(c0, tae, annos){
  periodos <- annos * 12
  i <-  tae / 12
  
  numerador <- (c0 * i)
  denominador <- 1 - (1 + i)^(-periodos)
  
  return(numerador / denominador)
}

calcula_cuota(150000, 0.0150, 25)
```

**Ejercicio 13 (compound interest).** Create a function for calculating the total amount we would have after a period of time given an interest rate. The inputs would be the original amount, the interest rate and the number of periods. The formula is:

$$\mbox{final amount} = \mbox{init amount} \cdot(1 + r)^{periods}$$

Try it with the different examples:

- If you invest 1000 € at a 7% annual interest rate, how much will you have after a year?
- If you invest 1000 € at a 7% annual interest rate, how much will you have after 10 years?
- If you have a deposit with your bank that guarantees a 1% quarter interest rate, how much will you have after a year?

```{r funct-13}
total_amount <- function(original_amount, interest_rate, periods){
  return(original_amount * (1 + interest_rate) ^ periods)
}

total_amount(1, 0.01, 4)
```
## Lists and loops

**Ejercicio 1.** Check the class of every column in the `dslabs::brexit_polls` data frame. _Hint._ Don't write `class` 9 times.

**Ejercicio 2.** Try creating a data frame with `map_dfr()` from `"CO_2017.csv"` and `"NO_2017.csv"`. What's going on?

**Ejercicio 3 (compound interest).** Using a function similar to the one you defined for the Ejercicio 13 on the previous function sections, create a loop for comparing what happens **after a year if you invest 1 €** at these different situations:

- 100% annual interest rate.
- 50% semeter interest rate.
- 25% quarter interest rate.
- 1/12 month interest rate.
- 1/365 daily interest rate.

The new function should have one only argument: the number of periods (1 period for annual interest rate, 2 period for semester, 4 for quaterly...). Do it in two different ways: using a _for_ loop and using `sapply()` or `map_dbl()`. It seems that if you kept on iterating with larger interest rates, the numbers would converged into a very special one. Do you know what this is?

```{r loops-3}
total_amount2 <- function(periods){
  return((1 + 1/periods) ^ periods)
}
sapply(c(1, 2, 4, 12, 365), total_amount2)
```

**Ejercicio 4.** Take the `dslabs::na_example` **vector** and replace every `NA` value with the previous record. _Remark._ This is a vector, not a dataframe. 

## Map

**Ejercicio 1.** Read the file `anscombe`.
**Ejercicio 2.** Get the class of all the columns.
**Ejercicio 3.** Get the mean of all the columns.
**Ejercicio 4.** Get the sd of all the columns.
**Ejercicio 5.** Calculate again the mean and the sd of all the columns and store them 
in the same list (each element will be a vector).
**Ejercicio 6.** Create a list of four data frames: each data frame will contain a pair
of columns x and y: the first one will contain x1 and y1, the second one
x2 and y2, and so on. `map()` should iterate over a vector `1:4` and 
you will create a function that select the columns containing the number.
**Ejercicio 7.** Calculate the correlation of all the pairs $x_i$ and $y_i$. You can
use your previous function because maybe you just have to add something
like `cor()`.

**Ejercicio 8.** Create scatter plots with those pairs. It may be easier changing 
the name of the columns inside your function using the function
`set_names()`.

**Ejercicio 9.** Read the `babynames` dataset. 

**Ejercicio 10.** We have selected the next set of names randomly. Create a list of summaries
of the data frames you obtain filtering by those names (use `map()` and
create a function that includes a filter and a summary).

```{r map-10, echo=TRUE}
nombres_random <- c("Mariyanna", "Lamiah", "Shandal",
                    "Rynda", "Kcee", "Camia",
                    "Isaiyah", "Barbare", "Braxon",
                    "Kailly")
```

**Ejercicio 11.** Create a list of size 2, each element having the 5 most used names for boys
and the same for girls.

**Ejercicio 12.** Create a vector with those names.

**Ejercicio 13.** For each name, count the number of years when it appeared

**Ejercicio 14.** For each name, create a column plot with the evolution of babies with 
that name per year. Use the name as the title.

```{r map-14}
map(names_most_used, function(x){
  babynames %>% 
    filter(name == x) %>% 
    ggplot(aes(x = year, y = n)) + 
    geom_col() + 
    labs(title = x)
})
```

**Ejercicio 15.** The same as before, but now color the columns differently if it is
a boys' name or girls' name.

```{r map-15}
map(names_most_used, function(x){
  df <- babynames %>% 
    filter(name == x)
  
  color <- if_else(df$sex == "F", "blue", "pink")
  
  ggplot(df, aes(x = year, y = n)) + 
    geom_col(fill = color) + 
    labs(title = x)
})
```


***

**Master in DS**
Introduction to programming

